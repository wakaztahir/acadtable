import types from "./types";

import Example from "./example.json";

import storage from "./storage";

window.onbeforeunload = storage.save;
window.onunload = storage.save;

//SYSTEM ACTIONS

export const showModal = (
  type = "waiting",
  content = null,
  actions = null,
  buttons = null
) => {
  return {
    type: types.SHOW_MODAL,
    payload: {
      display: true,
      type,
      content,
      actions,
      buttons
    }
  };
};
export const unshowModal = () => {
  return {
    type: types.UNSHOW_MODAL,
    payload: {
      display: false,
      type: null,
      message: null,
      buttons: null
    }
  };
};

export const showMenu = type => {
  return {
    type: types.SHOW_MENU,
    payload: {
      display: true,
      type
    }
  };
};

export const unshowMenu = type => {
  return {
    type: types.UNSHOW_MENU,
    payload: {
      display: false,
      type
    }
  };
};

//USER ACTIONS
export const exampleCollection = () => {
  let id =
    "exm" +
    Math.random()
      .toString()
      .substr(2, 6);
  storage.init(id);
  let collection = storage.set({
    id,
    name: "Example",
    desc: "This is an Example Collection generated by Acadtable.",
    time: new Date().toLocaleDateString()
  });
  storage.setData(Example);
  return {
    type: types.EXAMPLE_COLLECTION,
    payload: collection
  };
};

export const createCollection = (data = {}, background = null) => {
  storage.init();
  let collection = storage.set(data);
  if (background != null) {
    return collection;
  }
  return {
    type: types.CREATE_COLLECTION,
    payload: collection
  };
};
export const selectCollection = id => {
  storage.init(id);
  return {
    type: types.SELECT_COLLECTION,
    payload: {
      user: storage,
      tables: storage.getDataKey("tables"),
      days: storage.getDataKey("days"),
      places: storage.getDataKey("places"),
      lectures: storage.getDataKey("lectures"),
      batches: storage.getDataKey("batches"),
      times: storage.getDataKey("times"),
      subjects: storage.getDataKey("subjects"),
      teachers: storage.getDataKey("teachers")
    }
  };
};

export const deselectCollection = () => {
  return {
    type: types.DESELECT_COLLECTION,
    payload: null
  };
};
export const copyCollection = id => {
  let newid = storage.init();
  let collection = storage.get(id);
  collection.name += " Copy";
  collection.id = newid;
  collection = storage.set(collection);
  storage.setData(storage.getData(id));
  return {
    type: types.COPY_COLLECTION,
    payload: collection
  };
};
export const renameCollection = (id, newname) => {
  return {
    type: types.RENAME_COLLECTION,
    payload: {}
  };
};
export const deleteCollection = id => {
  storage.init(id);
  let deleted = storage.delete();
  return {
    type: types.DELETE_COLLECTION,
    payload: deleted
  };
};

//TABLE ACTIONS

export const createTable = (data, background = null) => {
  let table = storage.setDataItem("tables", null, data);
  if (background !== null) {
    return table;
  }
  return {
    type: types.CREATE_TABLE,
    payload: table
  };
};
export const updateTable = (tableID, data) => {
  let table = storage.setDataItem("tables", tableID, data);
  return {
    type: types.UPDATE_TABLE,
    payload: table
  };
};
export const deleteTable = tableID => {
  let table = storage.delDataItem("tables", tableID);
  return {
    type: types.DELETE_TABLE,
    payload: table
  };
};

//Lecture ACTIONS

export const createLecture = data => {
  let lecture = storage.setDataItem("lectures", null, data);
  return {
    type: types.CREATE_LECTURE,
    payload: lecture
  };
};
export const updateLecture = (lectureID, data) => {
  let lecture = storage.setDataItem("lectures", lectureID, data);
  return {
    type: types.UPDATE_LECTURE,
    payload: lecture
  };
};
export const deleteLecture = lectureID => {
  let lecture = storage.delDataItem("lectures", lectureID);
  return {
    type: types.DELETE_LECTURE,
    payload: lecture
  };
};

//DAY ACTIONS

export const createDay = (data, background = null) => {
  let day = storage.setDataItem("days", null, data);
  if (background !== null) {
    return day;
  }
  return {
    type: types.CREATE_DAY,
    payload: day
  };
};
export const updateDay = (dayID, data) => {
  let day = storage.setDataItem("days", dayID, data);
  return {
    type: types.UPDATE_DAY,
    payload: day
  };
};
export const swapDay = (dayID, withID) => {
  let days = Object.values(storage.getDataKey("days"));
  let current = days.filter(day => day.id === dayID)[0];
  let future = days.filter(day => day.id === withID)[0];
  for (let i = 0; i < days.length; i++) {
    if (days[i].id === dayID) {
      days[i] = future;
    } else if (days[i].id === withID) {
      days[i] = current;
    }
  }
  let newDays = {};
  days.forEach(day => {
    newDays[day.id] = day;
  });
  storage.setDataKey("days", newDays);
  return {
    type: types.SWAP_DAY,
    payload: {
      days: storage.getDataKey("days")
    }
  };
};
export const deleteDay = dayID => {
  let day = storage.delDataItem("days", dayID);
  return {
    type: types.DELETE_DAY,
    payload: day
  };
};

//TIME ACTIONS

export const createTime = (data, background = null) => {
  let time = storage.setDataItem("times", null, data);
  if (background !== null) {
    return time;
  }
  return {
    type: types.CREATE_TIME,
    payload: time
  };
};
export const updateTime = (timeID, data) => {
  let time = storage.setDataItem("times", timeID, data);
  return {
    type: types.UPDATE_TIME,
    payload: time
  };
};
export const swapTime = (timeID, withID) => {
  let times = Object.values(storage.getDataKey("times"));
  let current = times.filter(time => time.id === timeID)[0];
  let future = times.filter(time => time.id === withID)[0];
  for (let i = 0; i < times.length; i++) {
    if (times[i].id === timeID) {
      times[i] = future;
    } else if (times[i].id === withID) {
      times[i] = current;
    }
  }
  let newTimes = {};
  times.forEach(time => {
    newTimes[time.id] = time;
  });
  storage.setDataKey("times", newTimes);
  return {
    type: types.SWAP_TIME,
    payload: {
      times: storage.getDataKey("times")
    }
  };
};
export const deleteTime = timeID => {
  let time = storage.delDataItem("times", timeID);
  return {
    type: types.DELETE_TIME,
    payload: time
  };
};

//PLACE ACTIONS

export const createPlace = (data, background = null) => {
  let place = storage.setDataItem("places", null, data);
  if (background !== null) {
    return place;
  }
  return {
    type: types.CREATE_PLACE,
    payload: place
  };
};
export const updatePlace = (placeID, data) => {
  let place = storage.setDataItem("places", placeID, data);
  return {
    type: types.UPDATE_PLACE,
    payload: place
  };
};
export const swapPlace = (placeID, withID) => {
  let places = Object.values(storage.getDataKey("places"));
  let current = places.filter(place => place.id === placeID)[0];
  let future = places.filter(place => place.id === withID)[0];
  for (let i = 0; i < places.length; i++) {
    if (places[i].id === placeID) {
      places[i] = future;
    } else if (places[i].id === withID) {
      places[i] = current;
    }
  }
  let newPlaces = {};
  places.forEach(place => {
    newPlaces[place.id] = place;
  });
  storage.setDataKey("places", newPlaces);
  return {
    type: types.SWAP_PLACE,
    payload: {
      places: storage.getDataKey("places")
    }
  };
};
export const deletePlace = placeID => {
  let place = storage.delDataItem("places", placeID);
  return {
    type: types.DELETE_PLACE,
    payload: place
  };
};

//BATCH ACTIONS

export const createBatch = (data, background = null) => {
  let batch = storage.setDataItem("batches", null, data);
  if (background != null) {
    return batch;
  }
  return {
    type: types.CREATE_BATCH,
    payload: batch
  };
};
export const updateBatch = (batchID, data) => {
  let batch = storage.setDataItem("batches", batchID, data);
  return {
    type: types.UPDATE_BATCH,
    payload: batch
  };
};
export const swapBatch = (batchID, withID) => {
  let batches = Object.values(storage.getDataKey("batches"));
  let current = batches.filter(batch => batch.id === batchID)[0];
  let future = batches.filter(batch => batch.id === withID)[0];
  for (let i = 0; i < batches.length; i++) {
    if (batches[i].id === batchID) {
      batches[i] = future;
    } else if (batches[i].id === withID) {
      batches[i] = current;
    }
  }
  let newBatches = {};
  batches.forEach(batch => {
    newBatches[batch.id] = batch;
  });
  storage.setDataKey("batches", newBatches);
  return {
    type: types.SWAP_BATCH,
    payload: {
      batches: storage.getDataKey("batches")
    }
  };
};
export const deleteBatch = batchID => {
  let batch = storage.delDataItem("batches", batchID);
  return {
    type: types.DELETE_BATCH,
    payload: batch
  };
};

//SUBJECT ACTIONS

export const createSubject = (data, background = null) => {
  let subject = storage.setDataItem("subjects", null, data);
  if (background != null) {
    return subject;
  }
  return {
    type: types.CREATE_SUBJECT,
    payload: subject
  };
};
export const updateSubject = (subjectID, data) => {
  let subject = storage.setDataItem("subjects", subjectID, data);
  return {
    type: types.UPDATE_SUBJECT,
    payload: subject
  };
};
export const swapSubject = (subjectID, withID) => {
  let subjects = Object.values(storage.getDataKey("subjects"));
  let current = subjects.filter(subject => subject.id === subjectID)[0];
  let future = subjects.filter(subject => subject.id === withID)[0];
  for (let i = 0; i < subjects.length; i++) {
    if (subjects[i].id === subjectID) {
      subjects[i] = future;
    } else if (subjects[i].id === withID) {
      subjects[i] = current;
    }
  }
  let newSubjects = {};
  subjects.forEach(subject => {
    newSubjects[subject.id] = subject;
  });
  storage.setDataKey("subjects", newSubjects);
  return {
    type: types.SWAP_SUBJECT,
    payload: {
      subjects: storage.getDataKey("subjects")
    }
  };
};
export const deleteSubject = subjectID => {
  let subject = storage.delDataItem("subjects", subjectID);
  return {
    type: types.DELETE_SUBJECT,
    payload: subject
  };
};

//TEACHER ACTIONS

export const createTeacher = (data, background = null) => {
  let teacher = storage.setDataItem("teachers", null, data);
  if (background != null) {
    return teacher;
  }
  return {
    type: types.CREATE_TEACHER,
    payload: teacher
  };
};
export const updateTeacher = (teacherID, data) => {
  let teacher = storage.setDataItem("teachers", teacherID, data);
  return {
    type: types.UPDATE_TEACHER,
    payload: teacher
  };
};
export const swapTeacher = (teacherID, withID) => {
  let teachers = Object.values(storage.getDataKey("teachers"));
  let current = teachers.filter(teacher => teacher.id === teacherID)[0];
  let future = teachers.filter(teacher => teacher.id === withID)[0];
  for (let i = 0; i < teachers.length; i++) {
    if (teachers[i].id === teacherID) {
      teachers[i] = future;
    } else if (teachers[i].id === withID) {
      teachers[i] = current;
    }
  }
  let newTeachers = {};
  teachers.forEach(teacher => {
    newTeachers[teacher.id] = teacher;
  });
  storage.setDataKey("teachers", newTeachers);
  return {
    type: types.SWAP_TEACHER,
    payload: {
      teachers: storage.getDataKey("teachers")
    }
  };
};
export const deleteTeacher = teacherID => {
  let teacher = storage.delDataItem("teachers", teacherID);
  return {
    type: types.DELETE_TEACHER,
    payload: teacher
  };
};
